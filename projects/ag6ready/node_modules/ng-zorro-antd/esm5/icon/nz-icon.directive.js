/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isDevMode, Directive, ElementRef, Input, Renderer2 } from '@angular/core';
import { IconDirective } from '@ant-design/icons-angular';
import { NzIconService } from './nz-icon.service';
/**
 * This directive extends IconDirective to provide:
 *
 * - IconFont support
 * - spinning
 * - old API compatibility
 */
var NzIconDirective = /** @class */ (function (_super) {
    tslib_1.__extends(NzIconDirective, _super);
    function NzIconDirective(_iconService, _elementRef, _renderer) {
        var _this = _super.call(this, _iconService, _elementRef, _renderer) || this;
        _this._iconService = _iconService;
        _this._elementRef = _elementRef;
        _this._renderer = _renderer;
        _this.spin = false;
        return _this;
    }
    /**
     * In order to make this directive compatible to old API, we had do some ugly stuff here.
     * Should be removed in next major version.
     * @param {?} className
     * @return {?}
     */
    NzIconDirective.prototype._classChangeHandler = /**
     * In order to make this directive compatible to old API, we had do some ugly stuff here.
     * Should be removed in next major version.
     * @param {?} className
     * @return {?}
     */
    function (className) {
        if (!className) {
            return;
        }
        /** @type {?} */
        var forceSpin = className.indexOf('anticon-spin') > -1;
        /** @type {?} */
        var classArr = className.split(/\s/);
        /** @type {?} */
        var anticonType = classArr.filter(function (cls) { return cls !== 'anticon' && cls !== 'anticon-spin' && cls.match(/^anticon\-\w/); })[0];
        if (!anticonType) {
            return;
        }
        anticonType = anticonType.replace('anticon-', '');
        if (anticonType.includes('verticle')) {
            anticonType = anticonType.replace('verticle', 'vertical');
            if (!this._iconService.warnedAboutVertical) {
                console.warn('[NG-ZORRO]', "'verticle' is misspelled, would be corrected in the next major version.");
                this._iconService.warnedAboutVertical = true;
            }
        }
        if (anticonType.startsWith('cross')) {
            anticonType = anticonType.replace('cross', 'close');
            if (!this._iconService.warnedAboutCross) {
                console.warn('[NG-ZORRO]', "'cross' icon is replaced by 'close' icon.");
                this._iconService.warnedAboutCross = true;
            }
        }
        if (!(anticonType.endsWith('-o') || anticonType.endsWith('-fill') || anticonType.endsWith('-twotone'))) {
            anticonType += '-o';
        }
        if (this.type !== anticonType) {
            this.type = anticonType;
            this._changeIcon().catch(function (err) {
                console.warn('[NG-ZORRO]', "You can find more about this error on http://ng.ant.design/components/icon/en\n", err);
            });
        }
    };
    /**
     * @return {?}
     */
    NzIconDirective.prototype._warnAPI = /**
     * @return {?}
     */
    function () {
        if (isDevMode() && !this._iconService.warnedAboutAPI) {
            console.warn('[NG-ZORRO]', "<i class=\"anticon\"></i> would be deprecated soon. Please use <i nz-icon type=\"\"></i> API.");
        }
        this._iconService.warnedAboutAPI = true;
    };
    /**
     * @param {?} svg
     * @return {?}
     */
    NzIconDirective.prototype._addExtraModifications = /**
     * @param {?} svg
     * @return {?}
     */
    function (svg) {
        if (this.spin || this.type === 'loading') {
            this._renderer.addClass(this._el, 'anticon-spin');
        }
        else {
            this._renderer.removeClass(this._el, 'anticon-spin');
        }
    };
    /**
     * @return {?}
     */
    NzIconDirective.prototype._getIconNameBack = /**
     * @return {?}
     */
    function () {
        if (typeof this.type === 'string') {
            this._renderer.addClass(this._elementRef.nativeElement, "anticon-" + this.type);
        }
    };
    /**
     * @return {?}
     */
    NzIconDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.iconfont) {
            this._getIconNameBack(); // Should get back classNames immediately.
            this._changeIcon().then(function (svg) {
                _this._addExtraModifications(svg);
            }).catch(function () {
                console.warn('[NG-ZORRO]', "You can find more about this error on http://ng.ant.design/components/icon/en");
            });
        }
        else {
            this._setSVGElement(this._iconService.createIconfontIcon("#" + this.iconfont));
        }
    };
    /**
     * Subscribe to DOM element attribute change events, so when user use ngClass or something the icon changes with it.
     */
    /**
     * Subscribe to DOM element attribute change events, so when user use ngClass or something the icon changes with it.
     * @return {?}
     */
    NzIconDirective.prototype.ngOnInit = /**
     * Subscribe to DOM element attribute change events, so when user use ngClass or something the icon changes with it.
     * @return {?}
     */
    function () {
        var _this = this;
        this._el = this._elementRef.nativeElement;
        if (this._el && !this.type) {
            this._warnAPI();
            this._classChangeHandler(this._el.className);
            this._classNameObserver = new MutationObserver(function (mutations) {
                mutations
                    .filter(function (mutation) { return mutation.attributeName === 'class'; })
                    .forEach(function (mutation) { return _this._classChangeHandler((/** @type {?} */ (mutation.target)).className); });
            });
            this._classNameObserver.observe(this._elementRef.nativeElement, { attributes: true });
        }
        if (!this._el.classList.contains('anticon')) {
            this._renderer.setAttribute(this._el, 'class', "anticon " + this._el.className);
        }
    };
    /**
     * @return {?}
     */
    NzIconDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._classNameObserver) {
            this._classNameObserver.disconnect();
        }
    };
    /**
     * If custom content is provided, should try to normalize the svg element.
     */
    /**
     * If custom content is provided, should try to normalize the svg element.
     * @return {?}
     */
    NzIconDirective.prototype.ngAfterContentChecked = /**
     * If custom content is provided, should try to normalize the svg element.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var children = (/** @type {?} */ (this._elementRef.nativeElement)).children;
        if (children && children.length && !this.type) {
            /** @type {?} */
            var child = children[0];
            this._iconService.normalizeSvgElement(/** @type {?} */ (child));
        }
    };
    NzIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'i.anticon, [nz-icon]'
                },] }
    ];
    /** @nocollapse */
    NzIconDirective.ctorParameters = function () { return [
        { type: NzIconService },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    NzIconDirective.propDecorators = {
        spin: [{ type: Input }],
        iconfont: [{ type: Input }]
    };
    return NzIconDirective;
}(IconDirective));
export { NzIconDirective };
function NzIconDirective_tsickle_Closure_declarations() {
    /** @type {?} */
    NzIconDirective.prototype.spin;
    /** @type {?} */
    NzIconDirective.prototype.iconfont;
    /** @type {?} */
    NzIconDirective.prototype._classNameObserver;
    /** @type {?} */
    NzIconDirective.prototype._el;
    /** @type {?} */
    NzIconDirective.prototype._iconService;
    /** @type {?} */
    NzIconDirective.prototype._elementRef;
    /** @type {?} */
    NzIconDirective.prototype._renderer;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnotaWNvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy16b3Jyby1hbnRkLyIsInNvdXJjZXMiOlsiaWNvbi9uei1pY29uLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBRVQsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBSUwsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7Ozs7Ozs7OztJQVliLDJDQUFhO0lBcUVoRCx5QkFBbUIsWUFBMkIsRUFBUyxXQUF1QixFQUFTLFNBQW9CO1FBQTNHLFlBQ0Usa0JBQU0sWUFBWSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsU0FDNUM7UUFGa0Isa0JBQVksR0FBWixZQUFZLENBQWU7UUFBUyxpQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUFTLGVBQVMsR0FBVCxTQUFTLENBQVc7cUJBcEUzRixLQUFLOztLQXNFcEI7Ozs7Ozs7SUEzRE8sNkNBQW1COzs7Ozs7Y0FBQyxTQUFpQjtRQUMzQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQUUsT0FBTztTQUFFOztRQUUzQixJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOztRQUN6RCxJQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUN2QyxJQUFJLFdBQVcsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQUEsR0FBRyxJQUFJLE9BQUEsR0FBRyxLQUFLLFNBQVMsSUFBSSxHQUFHLEtBQUssY0FBYyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLEVBQXhFLENBQXdFLENBQUMsQ0FBRSxDQUFDLENBQUUsQ0FBQztR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LENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLGFBQVcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFXLENBQUMsQ0FBQztTQUNqRjtLQUNGOzs7O0lBRUQscUNBQVc7OztJQUFYO1FBQ0UsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQ3RDO0tBQ0Y7SUFFRDs7T0FFRzs7Ozs7SUFDSCwrQ0FBcUI7Ozs7SUFBckI7O1FBQ0UsSUFBTSxRQUFRLEdBQUcsbUJBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUE0QixFQUFDLENBQUMsUUFBUSxDQUFDO1FBQzFFLElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFOztZQUM3QyxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUUsQ0FBQyxDQUFFLENBQUM7WUFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxtQkFBbUIsbUJBQUMsS0FBbUIsRUFBQyxDQUFDO1NBQzVEO0tBQ0Y7O2dCQTdIRixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjtpQkFDakM7Ozs7Z0JBWFEsYUFBYTtnQkFScEIsVUFBVTtnQkFLVixTQUFTOzs7dUJBZ0JSLEtBQUs7MkJBQ0wsS0FBSzs7MEJBMUJSO0VBd0JxQyxhQUFhO1NBQXJDLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc0Rldk1vZGUsXG4gIEFmdGVyQ29udGVudENoZWNrZWQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFJlbmRlcmVyMlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEljb25EaXJlY3RpdmUgfSBmcm9tICdAYW50LWRlc2lnbi9pY29ucy1hbmd1bGFyJztcbmltcG9ydCB7IE56SWNvblNlcnZpY2UgfSBmcm9tICcuL256LWljb24uc2VydmljZSc7XG5cbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgZXh0ZW5kcyBJY29uRGlyZWN0aXZlIHRvIHByb3ZpZGU6XG4gKlxuICogLSBJY29uRm9udCBzdXBwb3J0XG4gKiAtIHNwaW5uaW5nXG4gKiAtIG9sZCBBUEkgY29tcGF0aWJpbGl0eVxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpLmFudGljb24sIFtuei1pY29uXSdcbn0pXG5leHBvcnQgY2xhc3MgTnpJY29uRGlyZWN0aXZlIGV4dGVuZHMgSWNvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudENoZWNrZWQge1xuICBASW5wdXQoKSBzcGluID0gZmFsc2U7XG4gIEBJbnB1dCgpIGljb25mb250OiBzdHJpbmc7XG5cbiAgLy8gcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgcHJpdmF0ZSBfY2xhc3NOYW1lT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIHByaXZhdGUgX2VsOiBIVE1MRWxlbWVudDtcblxuICAvKipcbiAgICogSW4gb3JkZXIgdG8gbWFrZSB0aGlzIGRpcmVjdGl2ZSBjb21wYXRpYmxlIHRvIG9sZCBBUEksIHdlIGhhZCBkbyBzb21lIHVnbHkgc3R1ZmYgaGVyZS5cbiAgICogU2hvdWxkIGJlIHJlbW92ZWQgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2xhc3NDaGFuZ2VIYW5kbGVyKGNsYXNzTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFjbGFzc05hbWUpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBmb3JjZVNwaW4gPSBjbGFzc05hbWUuaW5kZXhPZignYW50aWNvbi1zcGluJykgPiAtMTtcbiAgICBjb25zdCBjbGFzc0FyciA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzLyk7XG4gICAgbGV0IGFudGljb25UeXBlID0gY2xhc3NBcnIuZmlsdGVyKGNscyA9PiBjbHMgIT09ICdhbnRpY29uJyAmJiBjbHMgIT09ICdhbnRpY29uLXNwaW4nICYmIGNscy5tYXRjaCgvXmFudGljb25cXC1cXHcvKSlbIDAgXTtcblxuICAgIGlmICghYW50aWNvblR5cGUpIHsgcmV0dXJuOyB9XG5cbiAgICBhbnRpY29uVHlwZSA9IGFudGljb25UeXBlLnJlcGxhY2UoJ2FudGljb24tJywgJycpO1xuICAgIGlmIChhbnRpY29uVHlwZS5pbmNsdWRlcygndmVydGljbGUnKSkge1xuICAgICAgYW50aWNvblR5cGUgPSBhbnRpY29uVHlwZS5yZXBsYWNlKCd2ZXJ0aWNsZScsICd2ZXJ0aWNhbCcpO1xuICAgICAgaWYgKCF0aGlzLl9pY29uU2VydmljZS53YXJuZWRBYm91dFZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW05HLVpPUlJPXScsIGAndmVydGljbGUnIGlzIG1pc3NwZWxsZWQsIHdvdWxkIGJlIGNvcnJlY3RlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLmApO1xuICAgICAgICB0aGlzLl9pY29uU2VydmljZS53YXJuZWRBYm91dFZlcnRpY2FsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFudGljb25UeXBlLnN0YXJ0c1dpdGgoJ2Nyb3NzJykpIHtcbiAgICAgIGFudGljb25UeXBlID0gYW50aWNvblR5cGUucmVwbGFjZSgnY3Jvc3MnLCAnY2xvc2UnKTtcbiAgICAgIGlmICghdGhpcy5faWNvblNlcnZpY2Uud2FybmVkQWJvdXRDcm9zcykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tORy1aT1JST10nLCBgJ2Nyb3NzJyBpY29uIGlzIHJlcGxhY2VkIGJ5ICdjbG9zZScgaWNvbi5gKTtcbiAgICAgICAgdGhpcy5faWNvblNlcnZpY2Uud2FybmVkQWJvdXRDcm9zcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKGFudGljb25UeXBlLmVuZHNXaXRoKCctbycpIHx8IGFudGljb25UeXBlLmVuZHNXaXRoKCctZmlsbCcpIHx8IGFudGljb25UeXBlLmVuZHNXaXRoKCctdHdvdG9uZScpKSkge1xuICAgICAgYW50aWNvblR5cGUgKz0gJy1vJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSBhbnRpY29uVHlwZSkge1xuICAgICAgdGhpcy50eXBlID0gYW50aWNvblR5cGU7XG4gICAgICB0aGlzLl9jaGFuZ2VJY29uKCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tORy1aT1JST10nLCBgWW91IGNhbiBmaW5kIG1vcmUgYWJvdXQgdGhpcyBlcnJvciBvbiBodHRwOi8vbmcuYW50LmRlc2lnbi9jb21wb25lbnRzL2ljb24vZW5cXG5gLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF93YXJuQVBJKCk6IHZvaWQge1xuICAgIGlmIChpc0Rldk1vZGUoKSAmJiAhdGhpcy5faWNvblNlcnZpY2Uud2FybmVkQWJvdXRBUEkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW05HLVpPUlJPXScsIGA8aSBjbGFzcz1cImFudGljb25cIj48L2k+IHdvdWxkIGJlIGRlcHJlY2F0ZWQgc29vbi4gUGxlYXNlIHVzZSA8aSBuei1pY29uIHR5cGU9XCJcIj48L2k+IEFQSS5gKTtcbiAgICB9XG4gICAgdGhpcy5faWNvblNlcnZpY2Uud2FybmVkQWJvdXRBUEkgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfYWRkRXh0cmFNb2RpZmljYXRpb25zKHN2ZzogU1ZHRWxlbWVudCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNwaW4gfHwgdGhpcy50eXBlID09PSAnbG9hZGluZycpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsLCAnYW50aWNvbi1zcGluJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsLCAnYW50aWNvbi1zcGluJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0SWNvbk5hbWVCYWNrKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgdGhpcy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBgYW50aWNvbi0ke3RoaXMudHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgX2ljb25TZXJ2aWNlOiBOekljb25TZXJ2aWNlLCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHB1YmxpYyBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIHN1cGVyKF9pY29uU2VydmljZSwgX2VsZW1lbnRSZWYsIF9yZW5kZXJlcik7IC8vIE56SWNvblNlcnZpY2UgZXh0ZW5kcyBJY29uU2VydmljZSBzbyBJY29uRGlyZWN0aXZlIHdvbid0IGNvbXBsYWluLlxuICB9XG5cbiAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmljb25mb250KSB7XG4gICAgICB0aGlzLl9nZXRJY29uTmFtZUJhY2soKTsgLy8gU2hvdWxkIGdldCBiYWNrIGNsYXNzTmFtZXMgaW1tZWRpYXRlbHkuXG4gICAgICB0aGlzLl9jaGFuZ2VJY29uKCkudGhlbihzdmcgPT4ge1xuICAgICAgICB0aGlzLl9hZGRFeHRyYU1vZGlmaWNhdGlvbnMoc3ZnKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbTkctWk9SUk9dJywgYFlvdSBjYW4gZmluZCBtb3JlIGFib3V0IHRoaXMgZXJyb3Igb24gaHR0cDovL25nLmFudC5kZXNpZ24vY29tcG9uZW50cy9pY29uL2VuYCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0U1ZHRWxlbWVudCh0aGlzLl9pY29uU2VydmljZS5jcmVhdGVJY29uZm9udEljb24oYCMke3RoaXMuaWNvbmZvbnR9YCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gRE9NIGVsZW1lbnQgYXR0cmlidXRlIGNoYW5nZSBldmVudHMsIHNvIHdoZW4gdXNlciB1c2UgbmdDbGFzcyBvciBzb21ldGhpbmcgdGhlIGljb24gY2hhbmdlcyB3aXRoIGl0LlxuICAgKi9cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5fZWwgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuX2VsICYmICF0aGlzLnR5cGUpIHtcbiAgICAgIHRoaXMuX3dhcm5BUEkoKTtcbiAgICAgIHRoaXMuX2NsYXNzQ2hhbmdlSGFuZGxlcih0aGlzLl9lbC5jbGFzc05hbWUpO1xuICAgICAgdGhpcy5fY2xhc3NOYW1lT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKSA9PiB7XG4gICAgICAgIG11dGF0aW9uc1xuICAgICAgICAgIC5maWx0ZXIoKG11dGF0aW9uOiBNdXRhdGlvblJlY29yZCkgPT4gbXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gJ2NsYXNzJylcbiAgICAgICAgICAuZm9yRWFjaCgobXV0YXRpb246IE11dGF0aW9uUmVjb3JkKSA9PiB0aGlzLl9jbGFzc0NoYW5nZUhhbmRsZXIoKG11dGF0aW9uLnRhcmdldCBhcyBIVE1MRWxlbWVudCkuY2xhc3NOYW1lKSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2NsYXNzTmFtZU9ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbC5jbGFzc0xpc3QuY29udGFpbnMoJ2FudGljb24nKSkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2VsLCAnY2xhc3MnLCBgYW50aWNvbiAke3RoaXMuX2VsLmNsYXNzTmFtZX1gKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fY2xhc3NOYW1lT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX2NsYXNzTmFtZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgY3VzdG9tIGNvbnRlbnQgaXMgcHJvdmlkZWQsIHNob3VsZCB0cnkgdG8gbm9ybWFsaXplIHRoZSBzdmcgZWxlbWVudC5cbiAgICovXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggJiYgIXRoaXMudHlwZSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblsgMCBdO1xuICAgICAgdGhpcy5faWNvblNlcnZpY2Uubm9ybWFsaXplU3ZnRWxlbWVudChjaGlsZCBhcyBTVkdFbGVtZW50KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==