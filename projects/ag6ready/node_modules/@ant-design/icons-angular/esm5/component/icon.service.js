/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DOCUMENT } from '@angular/common';
import { HttpClient, HttpBackend } from '@angular/common/http';
import { Optional, Inject, RendererFactory2 } from '@angular/core';
import { of as observableOf } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { getSecondaryColor, withSuffix, isIconDefinition, printErr, printWarn, cloneSVG, withSuffixAndColor, getIconDefinitionFromAbbr, replaceFillColor } from '../utils';
var IconService = /** @class */ (function () {
    function IconService(_rendererFactory, _handler, _document) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.defaultTheme = 'outline';
        /**
         * Register icons.
         */
        this._svgDefinitions = new Map();
        /**
         * Register rendered (with color) SVG icons.
         */
        this._svgCachedDefinitions = new Map();
        /**
         * Default color settings.
         */
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        this._assetsSource = '';
        // For SSR.
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    Object.defineProperty(IconService.prototype, "twoToneColor", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (tslib_1.__assign({}, this.twoToneColor))); // Make a copy to avoid unexpected changes.
        },
        set: /**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var primaryColor = _a.primaryColor, secondaryColor = _a.secondaryColor;
            if (primaryColor && typeof primaryColor === 'string' && typeof secondaryColor === 'string' || typeof secondaryColor === 'undefined') {
                this._twoToneColorPalette.primaryColor = primaryColor;
                this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param icons
     */
    /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param {...?} icons
     * @return {?}
     */
    IconService.prototype.addIcon = /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param {...?} icons
     * @return {?}
     */
    function () {
        var icons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            icons[_i] = arguments[_i];
        }
        this._addIconLiteral.apply(this, tslib_1.__spread(icons));
    };
    /**
     * @param {?} prefix
     * @return {?}
     */
    IconService.prototype.changeAssetsSource = /**
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        this._assetsSource = prefix.endsWith('/') ? prefix : prefix + '/';
    };
    /**
     * Register icon.
     * @param icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     */
    /**
     * Register icon.
     * @param {...?} icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     * @return {?}
     */
    IconService.prototype._addIconLiteral = /**
     * Register icon.
     * @param {...?} icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     * @return {?}
     */
    function () {
        var _this = this;
        var icons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            icons[_i] = arguments[_i];
        }
        icons.forEach(function (icon) {
            _this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    };
    /**
     * @param {?} key
     * @return {?}
     */
    IconService.prototype._get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this._svgDefinitions.get(key) || null;
    };
    /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     */
    /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     * @param {?} url
     * @return {?}
     */
    IconService.prototype._getFromRemote = /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     * @param {?} url
     * @return {?}
     */
    function (url) {
        var _this = this;
        if (this._http) {
            /** @type {?} */
            var icon_1 = getIconDefinitionFromAbbr(url);
            return this._http.get(this._assetsSource + "assets/" + icon_1.theme + "/" + icon_1.name + ".svg", { responseType: 'text' }).pipe(map(function (svgString) {
                icon_1.icon = svgString;
                _this._addIconLiteral(icon_1);
                return icon_1;
            }), catchError(function () {
                printErr("the icon " + url + " does not exist in your assets folder");
                return observableOf(null);
            }));
        }
        else {
            printWarn('You need to import HttpClient module to use dynamic importing');
            return observableOf(null);
        }
    };
    /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon from URL, it would be async,
     * so we provided a unified interface here.
     *
     * TODO: namespace in the future
     */
    /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon from URL, it would be async,
     * so we provided a unified interface here.
     *
     * TODO: namespace in the future
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype.getRenderedContent = /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon from URL, it would be async,
     * so we provided a unified interface here.
     *
     * TODO: namespace in the future
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        var _this = this;
        /** @type {?} */
        var definitionOrNull = isIconDefinition(icon)
            ? (/** @type {?} */ (icon))
            : this._get((/** @type {?} */ (icon)));
        /** @type {?} */
        var $icon = definitionOrNull ? observableOf(definitionOrNull) : this._getFromRemote((/** @type {?} */ (icon)));
        return $icon.pipe(map(function (i) {
            if (i) {
                return _this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
            }
            else {
                printErr("the icon " + icon + " does not exist or is not registered");
                return null;
            }
        }));
    };
    /**
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype._loadSVGFromCacheOrCreateNew = /**
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        /** @type {?} */
        var svg;
        /** @type {?} */
        var pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        var sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        var key = withSuffixAndColor(icon.name, icon.theme, pri, sec);
        /** @type {?} */
        var cached = this._svgCachedDefinitions.get(key);
        // If this icon is used before, there should be a copy in cachedDefinitions, just copy it.
        // Otherwise, generate one from string or SVG element, and cache it.
        if (!cached) {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(typeof icon.icon === 'string'
                ? this._createSVGElementFromString(icon.icon)
                : icon.icon, (icon.theme === 'twotone'), pri, sec));
            this._svgCachedDefinitions.set(key, (/** @type {?} */ (tslib_1.__assign({}, icon, { icon: svg }))));
        }
        else {
            svg = cached.icon;
        }
        return cloneSVG(svg);
    };
    /**
     * @param {?} str
     * @return {?}
     */
    IconService.prototype._createSVGElementFromString = /**
     * @param {?} str
     * @return {?}
     */
    function (str) {
        /** @type {?} */
        var colorParsed = replaceFillColor(str);
        /** @type {?} */
        var div = this._document.createElement('div');
        div.innerHTML = colorParsed;
        /** @type {?} */
        var svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    };
    /**
     * @param {?} svg
     * @return {?}
     */
    IconService.prototype._setSVGAttribute = /**
     * @param {?} svg
     * @return {?}
     */
    function (svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    };
    /**
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    IconService.prototype._colorizeSVGIcon = /**
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    function (svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            var children = svg.childNodes;
            /** @type {?} */
            var length_1 = children.length;
            for (var i = 0; i < length_1; i++) {
                /** @type {?} */
                var child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    };
    /**
     * Clear all cached icons.
     */
    /**
     * Clear all cached icons.
     * @return {?}
     */
    IconService.prototype.clear = /**
     * Clear all cached icons.
     * @return {?}
     */
    function () {
        this._svgDefinitions.clear();
    };
    IconService.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: HttpBackend, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return IconService;
}());
export { IconService };
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /** @type {?} */
    IconService.prototype._renderer;
    /** @type {?} */
    IconService.prototype._http;
    /**
     * Register icons.
     * @type {?}
     */
    IconService.prototype._svgDefinitions;
    /**
     * Register rendered (with color) SVG icons.
     * @type {?}
     */
    IconService.prototype._svgCachedDefinitions;
    /**
     * Default color settings.
     * @type {?}
     */
    IconService.prototype._twoToneColorPalette;
    /** @type {?} */
    IconService.prototype._assetsSource;
    /** @type {?} */
    IconService.prototype._rendererFactory;
    /** @type {?} */
    IconService.prototype._handler;
    /** @type {?} */
    IconService.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RSxPQUFPLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBUWpELE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixRQUFRLEVBQ1IsU0FBUyxFQUNULFFBQVEsRUFDUixrQkFBa0IsRUFDbEIseUJBQXlCLEVBQUUsZ0JBQWdCLEVBQzVDLE1BQU0sVUFBVSxDQUFDO0FBRWxCO0lBbUxFLHFCQUNZLGdCQUFrQyxFQUN0QixRQUFxQixFQUNILFNBQWM7UUFGNUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUN0QixhQUFRLEdBQVIsUUFBUSxDQUFhO1FBQ0gsY0FBUyxHQUFULFNBQVMsQ0FBSztRQXJMeEQsaUJBQVksR0FBYyxTQUFTLENBQUM7UUFLcEM7O1dBRUc7UUFDTyxvQkFBZSxHQUFHLElBQUksR0FBRyxFQUEwQixDQUFDO1FBRTlEOztXQUVHO1FBQ08sMEJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQWdDLENBQUM7UUFFMUU7O1dBRUc7UUFDTyx5QkFBb0IsR0FBd0I7WUFDcEQsWUFBWSxFQUFJLFNBQVM7WUFDekIsY0FBYyxFQUFFLFNBQVM7U0FDMUIsQ0FBQztRQUVRLGtCQUFh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QyxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLGdCQUFnQixDQUFDLENBQUMsQ0FBQztvQkFDcEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDbEQsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDTixJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNsRCxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sQ0FBQyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7Ozs7O0lBQ0gsMkJBQUs7Ozs7SUFBTDtRQUNFLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDL0IsQ0FBQzs7Z0JBdE1tQyxnQkFBZ0I7Z0JBRGpDLFdBQVcsdUJBMk0zQixRQUFRO2dEQUNSLFFBQVEsWUFBSSxNQUFNLFNBQUMsUUFBUTs7SUFRaEMsa0JBQUM7Q0FBQSxBQTlMRCxJQThMQztTQTlMWSxXQUFXOzs7SUFDdEIsbUNBQW9DOztJQUVwQyxnQ0FBK0I7O0lBQy9CLDRCQUE0Qjs7Ozs7SUFLNUIsc0NBQThEOzs7OztJQUs5RCw0Q0FBMEU7Ozs7O0lBSzFFLDJDQUdFOztJQUVGLG9DQUE2Qjs7SUE0SjNCLHVDQUE0Qzs7SUFDNUMsK0JBQTJDOztJQUMzQyxnQ0FBc0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwQmFja2VuZCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9wdGlvbmFsLCBJbmplY3QsIFJlbmRlcmVyMiwgUmVuZGVyZXJGYWN0b3J5MiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBJY29uRGVmaW5pdGlvbixcbiAgQ2FjaGVkSWNvbkRlZmluaXRpb24sXG4gIFR3b1RvbmVDb2xvclBhbGV0dGUsXG4gIFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIsXG4gIFRoZW1lVHlwZSxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgZ2V0U2Vjb25kYXJ5Q29sb3IsXG4gIHdpdGhTdWZmaXgsXG4gIGlzSWNvbkRlZmluaXRpb24sXG4gIHByaW50RXJyLFxuICBwcmludFdhcm4sXG4gIGNsb25lU1ZHLFxuICB3aXRoU3VmZml4QW5kQ29sb3IsXG4gIGdldEljb25EZWZpbml0aW9uRnJvbUFiYnIsIHJlcGxhY2VGaWxsQ29sb3Jcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgSWNvblNlcnZpY2Uge1xuICBkZWZhdWx0VGhlbWU6IFRoZW1lVHlwZSA9ICdvdXRsaW5lJztcblxuICBwcm90ZWN0ZWQgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gIHByb3RlY3RlZCBfaHR0cDogSHR0cENsaWVudDtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgaWNvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3N2Z0RlZmluaXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIEljb25EZWZpbml0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciByZW5kZXJlZCAod2l0aCBjb2xvcikgU1ZHIGljb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zdmdDYWNoZWREZWZpbml0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZWRJY29uRGVmaW5pdGlvbj4oKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBjb2xvciBzZXR0aW5ncy5cbiAgICovXG4gIHByb3RlY3RlZCBfdHdvVG9uZUNvbG9yUGFsZXR0ZTogVHdvVG9uZUNvbG9yUGFsZXR0ZSA9IHtcbiAgICBwcmltYXJ5Q29sb3IgIDogJyMzMzMzMzMnLFxuICAgIHNlY29uZGFyeUNvbG9yOiAnI0U2RTZFNidcbiAgfTtcblxuICBwcm90ZWN0ZWQgX2Fzc2V0c1NvdXJjZSA9ICcnO1xuXG4gIHNldCB0d29Ub25lQ29sb3IoeyBwcmltYXJ5Q29sb3IsIHNlY29uZGFyeUNvbG9yIH06IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIpIHtcbiAgICBpZiAocHJpbWFyeUNvbG9yICYmIHR5cGVvZiBwcmltYXJ5Q29sb3IgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWNvbmRhcnlDb2xvciA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHNlY29uZGFyeUNvbG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZS5wcmltYXJ5Q29sb3IgPSBwcmltYXJ5Q29sb3I7XG4gICAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnNlY29uZGFyeUNvbG9yID0gc2Vjb25kYXJ5Q29sb3IgfHwgZ2V0U2Vjb25kYXJ5Q29sb3IocHJpbWFyeUNvbG9yKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdHdvVG9uZUNvbG9yKCk6IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIge1xuICAgIHJldHVybiB7IC4uLnRoaXMudHdvVG9uZUNvbG9yIH0gYXMgVHdvVG9uZUNvbG9yUGFsZXR0ZTsgLy8gTWFrZSBhIGNvcHkgdG8gYXZvaWQgdW5leHBlY3RlZCBjaGFuZ2VzLlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIEljb25EZWZpbml0aW9uIHByb3ZpZGVkIGJ5IEFudCBEZXNpZ24sIHBhcnNpbmcgQWJzdHJhY3ROb2RlIHRvIHN2ZyBzdHJpbmcuXG4gICAqIEBwYXJhbSBpY29uc1xuICAgKi9cbiAgYWRkSWNvbiguLi5pY29uczogSWNvbkRlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIHRoaXMuX2FkZEljb25MaXRlcmFsKC4uLmljb25zKTtcbiAgfVxuXG4gIGNoYW5nZUFzc2V0c1NvdXJjZShwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2Fzc2V0c1NvdXJjZSA9IHByZWZpeC5lbmRzV2l0aCgnLycpID8gcHJlZml4IDogcHJlZml4ICsgJy8nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGljb24uXG4gICAqIEBwYXJhbSBpY29ucyBJY29ucyB0aGF0IHVzZXJzIHdhbnQgdG8gdXNlIGluIHRoZWlyIHByb2plY3RzLiBVc2VyIGRlZmluZWQgaWNvbnMgYW5kIHByZWRlZmluZWRcbiAgICogICBpY29ucyBwcm92aWRlZCBieSBhbnQtZGVzaWduIHNob3VsZCBpbXBsZW1lbnQgSWNvbkRlZmluaXRpb24gYm90aC5cbiAgICovXG4gIHByb3RlY3RlZCBfYWRkSWNvbkxpdGVyYWwoLi4uaWNvbnM6IEljb25EZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBpY29ucy5mb3JFYWNoKGljb24gPT4ge1xuICAgICAgdGhpcy5fc3ZnRGVmaW5pdGlvbnMuc2V0KHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKSwgaWNvbik7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldChrZXk6IHN0cmluZyk6IEljb25EZWZpbml0aW9uIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z0RlZmluaXRpb25zLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHN0YXRpYyBmaWxlIGFuZCByZXR1cm4gaXQgYXMgYSBzdHJpbmcsIGNyZWF0ZSBhIEljb25EZWZpbml0aW9uIGFuZCBjYWNoZSBpdCBvciByZXR1cm4gbnVsbC5cbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0RnJvbVJlbW90ZSh1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24gfCBudWxsPiB7XG4gICAgaWYgKHRoaXMuX2h0dHApIHtcbiAgICAgIGNvbnN0IGljb246IEljb25EZWZpbml0aW9uID0gZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicih1cmwpO1xuICAgICAgcmV0dXJuIHRoaXMuX2h0dHAuZ2V0KFxuICAgICAgICBgJHt0aGlzLl9hc3NldHNTb3VyY2V9YXNzZXRzLyR7aWNvbi50aGVtZX0vJHtpY29uLm5hbWV9LnN2Z2AsXG4gICAgICAgIHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfVxuICAgICAgKS5waXBlKFxuICAgICAgICBtYXAoKHN2Z1N0cmluZzogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWNvbi5pY29uID0gc3ZnU3RyaW5nO1xuICAgICAgICAgIHRoaXMuX2FkZEljb25MaXRlcmFsKGljb24pO1xuICAgICAgICAgIHJldHVybiBpY29uO1xuICAgICAgICB9KSxcbiAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgICAgcHJpbnRFcnIoYHRoZSBpY29uICR7dXJsfSBkb2VzIG5vdCBleGlzdCBpbiB5b3VyIGFzc2V0cyBmb2xkZXJgKTtcbiAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG51bGwpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRXYXJuKCdZb3UgbmVlZCB0byBpbXBvcnQgSHR0cENsaWVudCBtb2R1bGUgdG8gdXNlIGR5bmFtaWMgaW1wb3J0aW5nJyk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJY29uIGNvbXBvbmVudCB3b3VsZCBjYWxsIHRoaXMgbWV0aG9kIHRvIGdldCBhIFNWRyBlbGVtZW50LlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgT2JzZXJ2YWJsZSBTVkcgZWxlbWVudCBiZWNhdXNlIHdoZW4gdXNlciB3YW50cyB0byBnZXQgYW4gaWNvbiBmcm9tIFVSTCwgaXQgd291bGQgYmUgYXN5bmMsXG4gICAqIHNvIHdlIHByb3ZpZGVkIGEgdW5pZmllZCBpbnRlcmZhY2UgaGVyZS5cbiAgICpcbiAgICogVE9ETzogbmFtZXNwYWNlIGluIHRoZSBmdXR1cmVcbiAgICovXG4gIGdldFJlbmRlcmVkQ29udGVudChpY29uOiBJY29uRGVmaW5pdGlvbiB8IHN0cmluZywgdHdvVG9uZUNvbG9yPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxTVkdFbGVtZW50IHwgbnVsbD4ge1xuICAgIGNvbnN0IGRlZmluaXRpb25Pck51bGw6IEljb25EZWZpbml0aW9uIHwgbnVsbCA9IGlzSWNvbkRlZmluaXRpb24oaWNvbilcbiAgICAgID8gaWNvbiBhcyBJY29uRGVmaW5pdGlvblxuICAgICAgOiB0aGlzLl9nZXQoaWNvbiBhcyBzdHJpbmcpO1xuICAgIGNvbnN0ICRpY29uID0gZGVmaW5pdGlvbk9yTnVsbCA/IG9ic2VydmFibGVPZihkZWZpbml0aW9uT3JOdWxsKSA6IHRoaXMuX2dldEZyb21SZW1vdGUoaWNvbiBhcyBzdHJpbmcpO1xuXG4gICAgcmV0dXJuICRpY29uLnBpcGUoXG4gICAgICBtYXAoaSA9PiB7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRTVkdGcm9tQ2FjaGVPckNyZWF0ZU5ldyhpLCB0d29Ub25lQ29sb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50RXJyKGB0aGUgaWNvbiAke2ljb259IGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCByZWdpc3RlcmVkYCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGljb246IEljb25EZWZpbml0aW9uLCB0d29Ub25lQ29sb3I/OiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBsZXQgc3ZnOiBTVkdFbGVtZW50O1xuICAgIGNvbnN0IHByaSA9IHR3b1RvbmVDb2xvciB8fCB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnByaW1hcnlDb2xvcjtcbiAgICBjb25zdCBzZWMgPSBnZXRTZWNvbmRhcnlDb2xvcihwcmkpIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3I7XG4gICAgY29uc3Qga2V5ID0gd2l0aFN1ZmZpeEFuZENvbG9yKGljb24ubmFtZSwgaWNvbi50aGVtZSwgcHJpLCBzZWMpO1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N2Z0NhY2hlZERlZmluaXRpb25zLmdldChrZXkpO1xuXG4gICAgLy8gSWYgdGhpcyBpY29uIGlzIHVzZWQgYmVmb3JlLCB0aGVyZSBzaG91bGQgYmUgYSBjb3B5IGluIGNhY2hlZERlZmluaXRpb25zLCBqdXN0IGNvcHkgaXQuXG4gICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBvbmUgZnJvbSBzdHJpbmcgb3IgU1ZHIGVsZW1lbnQsIGFuZCBjYWNoZSBpdC5cbiAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgc3ZnID0gdGhpcy5fc2V0U1ZHQXR0cmlidXRlKHRoaXMuX2NvbG9yaXplU1ZHSWNvbihcbiAgICAgICAgdHlwZW9mIGljb24uaWNvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICA/IHRoaXMuX2NyZWF0ZVNWR0VsZW1lbnRGcm9tU3RyaW5nKGljb24uaWNvbilcbiAgICAgICAgICA6IGljb24uaWNvblxuICAgICAgICAsIChpY29uLnRoZW1lID09PSAndHdvdG9uZScpLCBwcmksIHNlY1xuICAgICAgKSk7XG4gICAgICB0aGlzLl9zdmdDYWNoZWREZWZpbml0aW9ucy5zZXQoa2V5LCB7IC4uLmljb24sIGljb246IHN2ZyB9IGFzIENhY2hlZEljb25EZWZpbml0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnID0gY2FjaGVkLmljb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lU1ZHKHN2Zyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZVNWR0VsZW1lbnRGcm9tU3RyaW5nKHN0cjogc3RyaW5nKTogU1ZHRWxlbWVudCB7XG4gICAgY29uc3QgY29sb3JQYXJzZWQgPSByZXBsYWNlRmlsbENvbG9yKHN0cik7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmlubmVySFRNTCA9IGNvbG9yUGFyc2VkO1xuICAgIGNvbnN0IHN2ZzogU1ZHRWxlbWVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICBpZiAoIXN2Zykge1xuICAgICAgdGhyb3cgRXJyb3IoJzxzdmc+IHRhZyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0U1ZHQXR0cmlidXRlKHN2ZzogU1ZHRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICd3aWR0aCcsICcxZW0nKTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnaGVpZ2h0JywgJzFlbScpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbG9yaXplU1ZHSWNvbihzdmc6IFNWR0VsZW1lbnQsIHR3b3RvbmU6IGJvb2xlYW4sIHByaTogc3RyaW5nLCBzZWM6IHN0cmluZyk6IFNWR0VsZW1lbnQge1xuICAgIGlmICh0d290b25lKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHN2Zy5jaGlsZE5vZGVzO1xuICAgICAgY29uc3QgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZDogSFRNTEVsZW1lbnQgPSBjaGlsZHJlblsgaSBdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKCdmaWxsJykgPT09ICdzZWNvbmRhcnlDb2xvcicpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoY2hpbGQsICdmaWxsJywgc2VjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoY2hpbGQsICdmaWxsJywgcHJpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnZmlsbCcsICdjdXJyZW50Q29sb3InKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBjYWNoZWQgaWNvbnMuXG4gICAqL1xuICBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9zdmdEZWZpbml0aW9ucy5jbGVhcigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIF9yZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTIsXG4gICAgQE9wdGlvbmFsKCkgcHJvdGVjdGVkIF9oYW5kbGVyOiBIdHRwQmFja2VuZCxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcm90ZWN0ZWQgX2RvY3VtZW50OiBhbnlcbiAgKSB7XG4gICAgLy8gRm9yIFNTUi5cbiAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICBpZiAodGhpcy5faGFuZGxlcikge1xuICAgICAgdGhpcy5faHR0cCA9IG5ldyBIdHRwQ2xpZW50KHRoaXMuX2hhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuIl19